<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2022-05-30.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.experimental.local_stochastic_volatility.LocalStochasticVolatilityModel" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="dim"/>
<meta itemprop="property" content="drift_fn"/>
<meta itemprop="property" content="dtype"/>
<meta itemprop="property" content="fd_solver_backward"/>
<meta itemprop="property" content="fd_solver_forward"/>
<meta itemprop="property" content="from_market_data"/>
<meta itemprop="property" content="from_volatility_surface"/>
<meta itemprop="property" content="name"/>
<meta itemprop="property" content="sample_paths"/>
<meta itemprop="property" content="volatility_fn"/>
</div>

# tf_quant_finance.experimental.local_stochastic_volatility.LocalStochasticVolatilityModel

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/experimental/local_stochastic_volatility/local_stochastic_volatility_model.py">View source</a>



Local stochastic volatility model.

Inherits From: [`GenericItoProcess`](../../../tf_quant_finance/models/GenericItoProcess.md)

```python
tf_quant_finance.experimental.local_stochastic_volatility.LocalStochasticVolatilityModel(
    leverage_fn, variance_process, risk_free_rate=None, dividend_yield=None,
    rho=None, dtype=None, name=None
)
```



<!-- Placeholder for "Used in" -->

Local stochastic volatility (LSV) models assume that the spot price of an
asset follows the following stochastic differential equation under the risk
neutral measure [1]:

```None
  dS(t) / S(t) =  (r - d) dt + sqrt(v(t)) * L(t, S(t)) * dW_s(t)
  dv(t) = a(v(t)) dt + b(v(t)) dW_v(t)
  E[dW_s(t)dW_v(t)] = rho dt
```
where `r` and `d` denote the risk free interest rate and dividend yield
respectively. `S(t)` is the spot price, `v(t)` denotes the stochastic variance
and the function `L(t, S(t))`  is the leverage function which is calibrated
using the volatility smile data. The functions `a(v(t))` and `b(v(t))` denote
the drift and volitility of the stochastic process for the variance and `rho`
denotes the instantabeous correlation between the spot and the variance
process. LSV models thus combine the local volatility dynamics with
stochastic volatility.

Using the relationship between the local volatility and the expectation of
future instantaneous variance, leverage function can be computed as follows
[2]:

```
sigma(T,K)^2 = L(T,K)^2 * E[v(T)|S(T)=K]
```
where the local volatility function `sigma(T,K)` can be computed using the
Dupire's formula.

The `LocalStochasticVolatilityModel` class contains a generic implementation
of the LSV model with the flexibility to specify an arbitrary variance
process. The default variance process is a Heston type process with
mean-reverting variance (as in Ref. [1]):

```
dv(t) = k(m - v(t)) dt + alpha*sqrt(v(t)) dW_v(t)
```

#### References:
  [1]: Iain J. Clark. Foreign exchange option pricing - A Practitioner's
  guide. Chapter 5. 2011.
  [2]: I. Gyongy. Mimicking the one-dimensional marginal distributions of
  processes having an ito differential. Probability Theory and Related
  Fields, 71, 1986.

#### Args:


* <b>`leverage_fn`</b>: A Python callable which returns the Leverage function
  `L(t, S(t))` as a function of state and time. The function must accept
  a scalar `Tensor` corresponding to time 't' and a real `Tensor` of shape
  `[num_samples, 1]` corresponding to the underlying price (S) as
  inputs  and return a real `Tensor` containing the leverage function
  computed at (S,t).
* <b>`variance_process`</b>: An instance of `ItoProcess` specifying the
  dynamics of the variance process of the LSV model. The
  `variance_process` should implement a one-factor stochastic process.
  For the common version of Heston like variance model use
  `LSVVarianceModel`.
* <b>`risk_free_rate`</b>: An optional scalar real `Tensor` specifying the
  (continuously compounded) risk free interest rate. If the underlying is
  an FX rate, then use this input to specify the domestic interest rate.
  Note that the current implementation supports constant interest rates
  and dividend yield.
  Default value: `None` in which case the input is set to zero.
* <b>`dividend_yield`</b>: An optional real scalar `Tensor` specifying the
  (continuosly compounded) dividend yield. If the underlying is an FX
  rate, then use this input to specify the foreign interest rate.
  Note that the currect implementation supports constant interest rates
  and dividend yield.
  Default value: `None` in which case the input is set to zero.
* <b>`rho`</b>: A real scalar `Tensor` specifying the correlation between the
  underlying spot price and the variance process.
  Default value: `None` in which case cross correlations are assumed
  to be zero.
* <b>`dtype`</b>: The default dtype to use when converting values to `Tensor`s.
  Default value: `None` which means that default dtypes inferred by
  TensorFlow are used.
* <b>`name`</b>: Python string. The name to give to the ops created by this class.
  Default value: `None` which maps to the default name
  `local_stochastic_volatility_model`.

## Methods

<h3 id="dim"><code>dim</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
dim()
```

The dimension of the process.


<h3 id="drift_fn"><code>drift_fn</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
drift_fn()
```

Python callable calculating instantaneous drift.

The callable should accept two real `Tensor` arguments of the same dtype.
The first argument is the scalar time t, the second argument is the value of
Ito process X - `Tensor` of shape
`batch_shape + sample_shape + [dim]`, where `batch_shape` represents a batch
of models and `sample_shape` represents samples for each of the models. The
result is value of drift a(t, X). The return value of the callable is a real
`Tensor` of the same dtype as the input arguments and of shape
`batch_shape + sample_shape + [dim]`. For example, `sample_shape` can stand
for `[num_samples]` for Monte Carlo sampling, or
`[num_grid_points_1, ..., num_grid_points_dim]` for Finite Difference
solvers.

#### Returns:

The instantaneous drift rate callable.


<h3 id="dtype"><code>dtype</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
dtype()
```

The data type of process realizations.


<h3 id="fd_solver_backward"><code>fd_solver_backward</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
fd_solver_backward(
    start_time, end_time, coord_grid, values_grid, discounting=None,
    one_step_fn=None, boundary_conditions=None, start_step_count=0, num_steps=None,
    time_step=None, values_transform_fn=None, dtype=None, name=None, **kwargs
)
```

Returns a solver for Feynman-Kac PDE associated to the process.

This method applies a finite difference method to solve the final value
problem as it appears in the Feynman-Kac formula associated to this Ito
process. The Feynman-Kac PDE is closely related to the backward Kolomogorov
equation associated to the stochastic process and allows for the inclusion
of a discounting function.

For more details of the Feynman-Kac theorem see [1]. The PDE solved by this
method is:

```None
  V_t + Sum[mu_i(t, x) V_i, 1<=i<=n] +
    (1/2) Sum[ D_{ij} V_{ij}, 1 <= i,j <= n] - r(t, x) V = 0
```

In the above, `V_t` is the derivative of `V` with respect to `t`,
`V_i` is the partial derivative with respect to `x_i` and `V_{ij}` the
(mixed) partial derivative with respect to `x_i` and `x_j`. `mu_i` is the
drift of this process and `D_{ij}` are the components of the diffusion
tensor:

```None
  D_{ij}(t,x) = (Sigma(t,x) . Transpose[Sigma(t,x)])_{ij}
```

This method evolves a spatially discretized solution of the above PDE from
time `t0` to time `t1 < t0` (i.e. backwards in time).
The solution `V(t,x)` is assumed to be discretized on an `n`-dimensional
rectangular grid. A rectangular grid, G, in n-dimensions may be described
by specifying the coordinates of the points along each axis. For example,
a 2 x 4 grid in two dimensions can be specified by taking the cartesian
product of [1, 3] and [5, 6, 7, 8] to yield the grid points with
coordinates: `[(1, 5), (1, 6), (1, 7), (1, 8), (3, 5) ... (3, 8)]`.

This method allows batching of solutions. In this context, batching means
the ability to represent and evolve multiple independent functions `V`
(e.g. V1, V2 ...) simultaneously. A single discretized solution is specified
by stating its values at each grid point. This can be represented as a
`Tensor` of shape [d1, d2, ... dn] where di is the grid size along the `i`th
axis. A batch of such solutions is represented by a `Tensor` of shape:
`batch_shape + payoff_shape + [d1, d2, ... dn]` where `batch_shape` is the
batch of processes as in the underlying `drift_fn` and `volatility_fn` and
`payoff_shape` are the equations to be solved for each batch element.

The evolution of the solution from `t0` to `t1` is often done by
discretizing the differential equation to a difference equation along
the spatial and temporal axes. The temporal discretization is given by a
(sequence of) time steps [dt_1, dt_2, ... dt_k] such that the sum of the
time steps is equal to the total time step `t0 - t1`. If a uniform time
step is used, it may equivalently be specified by stating the number of
steps (n_steps) to take. This method provides both options via the
`time_step` and `num_steps` parameters. However, not all methods need
discretization along time direction (e.g. method of lines) so this argument
may not be applicable to some implementations.

The workhorse of this method is the `one_step_fn`. For the commonly used
methods, see functions in <a href="../../../tf_quant_finance/math/pde/steppers.md"><code>math.pde.steppers</code></a> module.

The mapping between the arguments of this method and the above
equation are described in the Args section below.

For a simple instructive example of implementation of this method, see
<a href="../../../tf_quant_finance/models/GenericItoProcess.md#fd_solver_backward"><code>models.GenericItoProcess.fd_solver_backward</code></a>.

#### Examples
```python
import tensorflow as tf
import numpy as np

import tf_quant_finance as tff
dtype = tf.float64

# Specify volatilities, interest rates and strikes for the options
volatilities = tf.constant([[0.3], [0.15], [0.1]], dtype)
rates = tf.constant([[0.01], [0.03], [0.01]], dtype)
expiries = 1.0

# Define Generic Ito Process

# Process dimensionality
dim = 1

# Batch size of the process
num_processes = 3

def drift_fn(t, x):
  del t
  # `x` is expected to be of shape [num_processes] + sample_shape + [dim]
  # We need to expand rank of rates to
  # `[num_processes] + extra_rank * [1] + [1]`
  expand_rank = x.shape.rank - 2
  rates_expand = tf.reshape(
      rates, [num_processes] + (expand_rank + 1) * [1])
  # Output is of shape [num_processes] + sample_shape + [dim]
  return rates_expand * x

def vol_fn(t, x):
  del t
  # `x` is expected to be of shape [num_processes] + sample_shape + [dim]
  # As before, need to expand rank of volatilities to
  # `[num_processes] + extra_rank * [1] + [1]`
  expand_rank = x.shape.rank - 2
  volatilities_expand = tf.reshape(
      volatilities, [num_processes] + (expand_rank + 1) * [1])
  # Output is of shape [num_processes] + sample_shape + [dim, dim]
  return (tf.expand_dims(volatilities_expand * x, axis=-1)
          * tf.eye(dim, batch_shape=x.shape.as_list()[:-1], dtype=x.dtype))

process = tff.models.GenericItoProcess(dim=dim,
                                       drift_fn=drift_fn,
                                       volatility_fn=vol_fn,
                                       dtype=dtype)
# Define a 2 strikes for each batch process,
num_strikes = 2
# Shape [num_processes, num_strikes, 1]. Here 1 at the end is just for
# convenience
strikes = tf.constant([[[50], [60]], [[100], [90]], [[120], [90]]], dtype)

# Price a batch of European call options
@tff.math.pde.boundary_conditions.dirichlet
def upper_boundary_fn(t, grid):
  del grid
  # Shape (num_processes, num_strikes)
  return tf.squeeze(s_max - strikes * tf.exp(-rates  * (expiries - t)))

# Define discounting function
def discounting(t, x):
  del t, x
  rates_expand = tf.expand_dims(rates, axis=-1)
  # Shape compatible with (num_processes, num_strikes)
  return rates_expand

# Build a uniform grid
s_min = 0
s_max = 200
num_grid_points = 256  # Number of grid points

grid = tff.math.pde.grids.uniform_grid(minimums=[s_min],
                                       maximums=[s_max],
                                       sizes=[num_grid_points],
                                       dtype=dtype)

# Shape [num_processes, num_strikes, num_grid_points]
final_value_grid = tf.nn.relu(grid[0] - strikes)

# Estimated prices for the European options
process.fd_solver_backward(
    start_time=expiries,
    end_time=0,
    time_step=0.1,
    coord_grid=grid,
    values_grid=final_value_grid,
    discounting=discounting,
    boundary_condtions=[(None, upper_boundary_fn)])[0]
# Shape of the output is [num_processes, num_strikes, num_grid_points]
```

#### Args:


* <b>`start_time`</b>: Real positive scalar `Tensor`. The start time of the grid.
  Corresponds to time `t0` above.
* <b>`end_time`</b>: Real scalar `Tensor` smaller than the `start_time` and greater
  than zero. The time to step back to. Corresponds to time `t1` above.
* <b>`coord_grid`</b>: List of `n` rank 1 real `Tensor`s. `n` is the dimension of the
  domain. The i-th `Tensor` has shape, `[d_i]` where `d_i` is the size of
  the grid along axis `i`. The coordinates of the grid points. Corresponds
  to the spatial grid `G` above.
* <b>`values_grid`</b>: Real `Tensor` containing the function values at time
  `start_time` which have to be stepped back to time `end_time`. The shape
  of the `Tensor` must broadcast with
  `batch_shape + payoff_shape + [d_1, d_2, ..., d_n]`. `batch_shape`
  represents the batch of the processes as in the underlying `drift_fn`
  and `volatility_fn`. `payoff_shape` specifies equations to be solved for
  each batch element (with potentially different boundary/final conditions
  and for various coordinate grids). When the batch dimensions
  `batch_shape` or `payoff_shape` are present, the shape of values_grid`
  must be at least `batch_shape + payoff_shape + dim * [1]`.
* <b>`discounting`</b>: Callable corresponding to `r(t,x)` above. If not supplied,
  zero discounting is assumed.
* <b>`one_step_fn`</b>: The transition kernel. A callable that consumes the following
  arguments by keyword:
    1. 'time': Current time
    2. 'next_time': The next time to step to. For the backwards in time
      evolution, this time will be smaller than the current time.
    3. 'coord_grid': The coordinate grid.
    4. 'values_grid': The values grid.
    5. 'boundary_conditions': The boundary conditions.
    6. 'quadratic_coeff': A callable returning the quadratic coefficients
      of the PDE (i.e. `(1/2)D_{ij}(t, x)` above). The callable accepts
      the time and  coordinate grid as keyword arguments and returns a
      `Tensor` with shape that broadcasts with `[dim, dim]`.
    7. 'linear_coeff': A callable returning the linear coefficients of the
      PDE (i.e. `mu_i(t, x)` above). Accepts time and coordinate grid as
      keyword arguments and returns a `Tensor` with shape that broadcasts
      with `[dim]`.
    8. 'constant_coeff': A callable returning the coefficient of the
      linear homogeneous term (i.e. `r(t,x)` above). Same spec as above.
      The `one_step_fn` callable returns a 2-tuple containing the next
      coordinate grid, next values grid.
* <b>`boundary_conditions`</b>: The boundary conditions. Only rectangular boundary
  conditions are supported. A list of tuples of size `n` (space dimension
  of the PDE). The elements of the Tuple can be either a Python Callable
  or `None` representing the boundary conditions at the minimum and
  maximum values of the spatial variable indexed by the position in the
  list. E.g., for `n=2`, the length of `boundary_conditions` should be 2,
  `boundary_conditions[0][0]` describes the boundary `(y_min, x)`, and
  `boundary_conditions[1][0]`- the boundary `(y, x_min)`. `None` values
  mean that the second order terms for that dimension on the boundary are
  assumed to be zero, i.e., if `boundary_conditions[k][0]` is `None`,
  'dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 1 <= i, j <= n, i!=k+1, j!=k+1]
     + Sum[b_i d(B_i V)/dx_i, 1 <= i <= n] + c V = 0.'
  For not `None` values, the boundary conditions are accepted in the form
  `alpha(t, x) V + beta(t, x) V_n = gamma(t, x)`, where `V_n` is the
  derivative with respect to the exterior normal to the boundary.
  Each callable receives the current time `t` and the `coord_grid` at the
  current time, and should return a tuple of `alpha`, `beta`, and `gamma`.
  Each can be a number, a zero-rank `Tensor` or a `Tensor` whose shape is
  the grid shape with the corresponding dimension removed.
  For example, for a two-dimensional grid of shape `(b, ny, nx)`, where
  `b` is the batch size, `boundary_conditions[0][i]` with `i = 0, 1`
  should return a tuple of either numbers, zero-rank tensors or tensors of
  shape `(b, nx)`. Similarly for `boundary_conditions[1][i]`, except the
  tensor shape should be `(b, ny)`. `alpha` and `beta` can also be `None`
  in case of Neumann and Dirichlet conditions, respectively.
  Default value: `None`. Unlike setting `None` to individual elements of
  `boundary_conditions`, setting the entire `boundary_conditions` object
  to `None` means Dirichlet conditions with zero value on all boundaries
  are applied.
* <b>`start_step_count`</b>: Scalar integer `Tensor`. Initial value for the number of
  time steps performed.
  Default value: 0 (i.e. no previous steps performed).
* <b>`num_steps`</b>: Positive int scalar `Tensor`. The number of time steps to take
  when moving from `start_time` to `end_time`. Either this argument or the
  `time_step` argument must be supplied (but not both). If num steps is
  `k>=1`, uniform time steps of size `(t0 - t1)/k` are taken to evolve the
  solution from `t0` to `t1`. Corresponds to the `n_steps` parameter
  above.
* <b>`time_step`</b>: The time step to take. Either this argument or the `num_steps`
  argument must be supplied (but not both). The type of this argument may
  be one of the following (in order of generality): (a) None in which case
    `num_steps` must be supplied. (b) A positive real scalar `Tensor`. The
    maximum time step to take. If the value of this argument is `dt`, then
    the total number of steps taken is N = (t0 - t1) / dt rounded up to
    the nearest integer. The first N-1 steps are of size dt and the last
    step is of size `t0 - t1 - (N-1) * dt`. (c) A callable accepting the
    current time and returning the size of the step to take. The input and
    the output are real scalar `Tensor`s.
* <b>`values_transform_fn`</b>: An optional callable applied to transform the
  solution values at each time step. The callable is invoked after the
  time step has been performed. The callable should accept the time of the
  grid, the coordinate grid and the values grid and should return the
  values grid. All input arguments to be passed by keyword.
* <b>`dtype`</b>: The dtype to use.
* <b>`name`</b>: The name to give to the ops.
  Default value: None which means `solve_backward` is used.
* <b>`**kwargs`</b>: Additional keyword args:
  (1) pde_solver_fn: Function to solve the PDE that accepts all the above
    arguments by name and returns the same tuple object as required below.
    Defaults to `tff.math.pde.fd_solvers.solve_backward`.


#### Returns:

A tuple object containing at least the following attributes:
  final_values_grid: A `Tensor` of same shape and dtype as `values_grid`.
    Contains the final state of the values grid at time `end_time`.
  final_coord_grid: A list of `Tensor`s of the same specification as
    the input `coord_grid`. Final state of the coordinate grid at time
    `end_time`.
  step_count: The total step count (i.e. the sum of the `start_step_count`
    and the number of steps performed in this call.).
  final_time: The final time at which the evolution stopped. This value
    is given by `max(min(end_time, start_time), 0)`.


<h3 id="fd_solver_forward"><code>fd_solver_forward</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
fd_solver_forward(
    start_time, end_time, coord_grid, values_grid, one_step_fn=None,
    boundary_conditions=None, start_step_count=0, num_steps=None, time_step=None,
    values_transform_fn=None, dtype=None, name=None, **kwargs
)
```

Returns a solver for the Fokker Plank equation of this process.

The Fokker Plank equation (also known as the Kolmogorov Forward equation)
associated to this Ito process is given by:

```None
  V_t + Sum[(mu_i(t, x) V)_i, 1<=i<=n]
    - (1/2) Sum[ (D_{ij} V)_{ij}, 1 <= i,j <= n] = 0
```

with the initial value condition $$V(0, x) = u(x)$$.

This method evolves a spatially discretized solution of the above PDE from
time `t0` to time `t1 > t0` (i.e. forwards in time).
The solution `V(t,x)` is assumed to be discretized on an `n`-dimensional
rectangular grid. A rectangular grid, G, in n-dimensions may be described
by specifying the coordinates of the points along each axis. For example,
a 2 x 4 grid in two dimensions can be specified by taking the cartesian
product of [1, 3] and [5, 6, 7, 8] to yield the grid points with
coordinates: `[(1, 5), (1, 6), (1, 7), (1, 8), (3, 5) ... (3, 8)]`.

This method allows batching of solutions. In this context, batching means
the ability to represent and evolve multiple independent functions `V`
(e.g. V1, V2 ...) simultaneously. A single discretized solution is specified
by stating its values at each grid point. This can be represented as a
`Tensor` of shape [d1, d2, ... dn] where di is the grid size along the `i`th
axis. A batch of such solutions is represented by a `Tensor` of shape:
`batch_shape + payoff_shape + [d1, d2, ... dn]` where `batch_shape` is the
batch of processes as in the underlying `drift_fn` and `volatility_fn` and
`payoff_shape` are the equations to be solved for each batch element.

The evolution of the solution from `t0` to `t1` is often done by
discretizing the differential equation to a difference equation along
the spatial and temporal axes. The temporal discretization is given by a
(sequence of) time steps [dt_1, dt_2, ... dt_k] such that the sum of the
time steps is equal to the total time step `t1 - t0`. If a uniform time
step is used, it may equivalently be specified by stating the number of
steps (n_steps) to take. This method provides both options via the
`time_step` and `num_steps` parameters. However, not all methods need
discretization along time direction (e.g. method of lines) so this argument
may not be applicable to some implementations.

The workhorse of this method is the `one_step_fn`. For the commonly used
methods, see functions in <a href="../../../tf_quant_finance/math/pde/steppers.md"><code>math.pde.steppers</code></a> module.

The mapping between the arguments of this method and the above
equation are described in the Args section below.

For a simple instructive example of implementation of this method, see
<a href="../../../tf_quant_finance/models/GenericItoProcess.md#fd_solver_forward"><code>models.GenericItoProcess.fd_solver_forward</code></a>.

#### Args:


* <b>`start_time`</b>: Real positive scalar `Tensor`. The start time of the grid.
  Corresponds to time `t0` above.
* <b>`end_time`</b>: Real scalar `Tensor` smaller than the `start_time` and greater
  than zero. The time to step back to. Corresponds to time `t1` above.
* <b>`coord_grid`</b>: List of `n` rank 1 real `Tensor`s. `n` is the dimension of the
  domain. The i-th `Tensor` has shape, `[d_i]` where `d_i` is the size of
  the grid along axis `i`. The coordinates of the grid points. Corresponds
  to the spatial grid `G` above.
* <b>`values_grid`</b>: Real `Tensor` containing the function values at time
  `start_time` which have to be stepped back to time `end_time`. The shape
  of the `Tensor` must broadcast with
  `batch_shape + payoff_shape + [d_1, d_2, ..., d_n]`. `batch_shape`
  represents the batch of the processes as in the underlying `drift_fn`
  and `volatility_fn`. `payoff_shape` specifies equations to be solved for
  each batch element (with potentially different boundary/final conditions
  and for various coordinate grids). When the batch dimensions
  `batch_shape` or `payoff_shape` are present, the shape of values_grid`
  must be at least `batch_shape + payoff_shape + dim * [1]`.
* <b>`one_step_fn`</b>: The transition kernel. A callable that consumes the following
  arguments by keyword:
    1. 'time': Current time
    2. 'next_time': The next time to step to. For the backwards in time
      evolution, this time will be smaller than the current time.
    3. 'coord_grid': The coordinate grid.
    4. 'values_grid': The values grid.
    5. 'quadratic_coeff': A callable returning the quadratic coefficients
      of the PDE (i.e. `(1/2)D_{ij}(t, x)` above). The callable accepts
      the time and  coordinate grid as keyword arguments and returns a
      `Tensor` with shape that broadcasts with `[dim, dim]`.
    6. 'linear_coeff': A callable returning the linear coefficients of the
      PDE (i.e. `mu_i(t, x)` above). Accepts time and coordinate grid as
      keyword arguments and returns a `Tensor` with shape that broadcasts
      with `[dim]`.
    7. 'constant_coeff': A callable returning the coefficient of the
      linear homogeneous term (i.e. `r(t,x)` above). Same spec as above.
      The `one_step_fn` callable returns a 2-tuple containing the next
      coordinate grid, next values grid.
* <b>`boundary_conditions`</b>: The boundary conditions. Only rectangular boundary
  conditions are supported. A list of tuples of size `n` (space dimension
  of the PDE). The elements of the Tuple can be either a Python Callable
  or `None` representing the boundary conditions at the minimum and
  maximum values of the spatial variable indexed by the position in the
  list. E.g., for `n=2`, the length of `boundary_conditions` should be 2,
  `boundary_conditions[0][0]` describes the boundary `(y_min, x)`, and
  `boundary_conditions[1][0]`- the boundary `(y, x_min)`. `None` values
  mean that the second order terms for that dimension on the boundary are
  assumed to be zero, i.e., if `boundary_conditions[k][0]` is `None`,
  'dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 1 <= i, j <= n, i!=k+1, j!=k+1]
     + Sum[b_i d(B_i V)/dx_i, 1 <= i <= n] + c V = 0.'
  For not `None` values, the boundary conditions are accepted in the form
  `alpha(t, x) V + beta(t, x) V_n = gamma(t, x)`, where `V_n` is the
  derivative with respect to the exterior normal to the boundary.
  Each callable receives the current time `t` and the `coord_grid` at the
  current time, and should return a tuple of `alpha`, `beta`, and `gamma`.
  Each can be a number, a zero-rank `Tensor` or a `Tensor` whose shape is
  the grid shape with the corresponding dimension removed.
  For example, for a two-dimensional grid of shape `(b, ny, nx)`, where
  `b` is the batch size, `boundary_conditions[0][i]` with `i = 0, 1`
  should return a tuple of either numbers, zero-rank tensors or tensors of
  shape `(b, nx)`. Similarly for `boundary_conditions[1][i]`, except the
  tensor shape should be `(b, ny)`. `alpha` and `beta` can also be `None`
  in case of Neumann and Dirichlet conditions, respectively.
  Default value: `None`. Unlike setting `None` to individual elements of
  `boundary_conditions`, setting the entire `boundary_conditions` object
  to `None` means Dirichlet conditions with zero value on all boundaries
  are applied.
* <b>`start_step_count`</b>: Scalar integer `Tensor`. Initial value for the number of
  time steps performed.
  Default value: 0 (i.e. no previous steps performed).
* <b>`num_steps`</b>: Positive int scalar `Tensor`. The number of time steps to take
  when moving from `start_time` to `end_time`. Either this argument or the
  `time_step` argument must be supplied (but not both). If num steps is
  `k>=1`, uniform time steps of size `(t0 - t1)/k` are taken to evolve the
  solution from `t0` to `t1`. Corresponds to the `n_steps` parameter
  above.
* <b>`time_step`</b>: The time step to take. Either this argument or the `num_steps`
  argument must be supplied (but not both). The type of this argument may
  be one of the following (in order of generality): (a) None in which case
    `num_steps` must be supplied. (b) A positive real scalar `Tensor`. The
    maximum time step to take. If the value of this argument is `dt`, then
    the total number of steps taken is N = (t1 - t0) / dt rounded up to
    the nearest integer. The first N-1 steps are of size dt and the last
    step is of size `t1 - t0 - (N-1) * dt`. (c) A callable accepting the
    current time and returning the size of the step to take. The input and
    the output are real scalar `Tensor`s.
* <b>`values_transform_fn`</b>: An optional callable applied to transform the
  solution values at each time step. The callable is invoked after the
  time step has been performed. The callable should accept the time of the
  grid, the coordinate grid and the values grid and should return the
  values grid. All input arguments to be passed by keyword.
* <b>`dtype`</b>: The dtype to use.
* <b>`name`</b>: The name to give to the ops.
  Default value: None which means `solve_forward` is used.
* <b>`**kwargs`</b>: Additional keyword args:
  (1) pde_solver_fn: Function to solve the PDE that accepts all the above
    arguments by name and returns the same tuple object as required below.
    Defaults to `tff.math.pde.fd_solvers.solve_forward`.


#### Returns:

A tuple object containing at least the following attributes:
  final_values_grid: A `Tensor` of same shape and dtype as `values_grid`.
    Contains the final state of the values grid at time `end_time`.
  final_coord_grid: A list of `Tensor`s of the same specification as
    the input `coord_grid`. Final state of the coordinate grid at time
    `end_time`.
  step_count: The total step count (i.e. the sum of the `start_step_count`
    and the number of steps performed in this call.).
  final_time: The final time at which the evolution stopped. This value
    is given by `max(min(end_time, start_time), 0)`.


<h3 id="from_market_data"><code>from_market_data</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/experimental/local_stochastic_volatility/local_stochastic_volatility_model.py">View source</a>

```python
@classmethod
from_market_data(
    cls, valuation_date, expiry_dates, strikes, implied_volatilities,
    variance_process, initial_spot, initial_variance, rho=None, risk_free_rate=None,
    dividend_yield=None, time_step=None, num_grid_points=None, grid_minimums=None,
    grid_maximums=None, dtype=None
)
```

Creates a `LocalStochasticVolatilityModel` from market data.

This function computes the leverage function for the LSV model by first
computing the joint probability density function `p(t, X(t), v(t))` where
`X(t)` is the log of the spot price and `v(t)` is the variance at time `t`.
The joint probablity density is computed using the Fokker-Planck equation of
the LSV model (see 6.8.2 in Ref [1]):

```None
dp/dt = 1/2 d^2 [v L(t,X)^2 p]/dX^2 + 1/2 d^2 [b(v)^2 p]/dv^2 +
        rho d^2 [sqrt(v)L(t,X)b(v) p]/dXdv -
        d[(r - d - 1/2 v L(t,X)^2)p]/dX -
        d[a(v) p]/dv
```

where `a(v)` and `b(v)` are the drift and diffusion functions for the
variance process. Defining

```None
I_n(k,t) = int v^n p(t, k, v) dv
```

we can calculate the leverage function as follows:
```None
L(k, t) = sigma(exp(k), t) sqrt(I_0(k, t)/I_1(k, t)).
```

Note that the computation of `I_0` and `I_1` require the knowledge of
leverage function and hence the computation of the leverage function is
implicit in nature.

#### Args:


* <b>`valuation_date`</b>: A scalar `DateTensor` specifying the valuation
  (or settlement) date for the market data.
* <b>`expiry_dates`</b>: A `DateTensor` of shape `(num_expiries,)` containing the
  expiry dates on which the implied volatilities are specified.
* <b>`strikes`</b>: A `Tensor` of real dtype and shape `(num_expiries,
  num_strikes)` specifying the strike prices at which implied volatilities
  are specified.
* <b>`implied_volatilities`</b>: A `Tensor` of real dtype and shape `(num_expiries,
  num_strikes)` specifying the implied volatilities.
* <b>`variance_process`</b>: An instance of `LSVVarianceModel` or
  `ItoProcess` specifying the dynamics of the variance process of
  the LSV model.
* <b>`initial_spot`</b>: A real scalar `Tensor` specifying the underlying spot price
  on the valuation date.
* <b>`initial_variance`</b>: A real scalar `Tensor` specifying the initial variance
  on the valuation date.
* <b>`rho`</b>: A real scalar `Tensor` specifying the correlation between spot price
  and the stochastic variance.
* <b>`risk_free_rate`</b>: A real scalar `Tensor` specifying the (continuosly
  compounded) risk free interest rate. If the underlying is an FX rate,
  then use this input to specify the domestic interest rate.
  Default value: `None` in which case the input is set to zero.
* <b>`dividend_yield`</b>: A real scalar `Tensor` specifying the (continuosly
  compounded) divident yield. If the underlying is an FX rate, then use
  this input to specify the foreign interest rate.
  Default value: `None` in which case the input is set to zero.
* <b>`time_step`</b>: A real scalar `Tensor` specifying the time step during the
  numerical solution of the Fokker-Planck PDE.
  Default value: None, in which case `time_step` corresponding to 100 time
    steps is used.
* <b>`num_grid_points`</b>: A scalar integer `Tensor` specifying the number of
  discretization points for each spatial dimension.
  Default value: None, in which case number of grid points is set to 100.
* <b>`grid_minimums`</b>: An optional `Tensor` of size 2 containing the minimum grid
  points for PDE spatial discretization. `grid_minimums[0]` correspond
  to the minimum spot price in the spatial grid and `grid_minimums[1]`
  correspond to the minimum variance value.
* <b>`grid_maximums`</b>: An optional `Tensor` of size 2 containing the maximum grid
  points for PDE spatial discretization. `grid_maximums[0]` correspond
  to the maximum spot price in the spatial grid and `grid_maximums[1]`
  correspond to the maximum variance value.
* <b>`dtype`</b>: The default dtype to use when converting values to `Tensor`s.
  Default value: `None` which means that default dtypes inferred by
    TensorFlow are used.


#### Returns:

An instance of `LocalStochasticVolatilityModel` constructed using the
input data.


<h3 id="from_volatility_surface"><code>from_volatility_surface</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/experimental/local_stochastic_volatility/local_stochastic_volatility_model.py">View source</a>

```python
@classmethod
from_volatility_surface(
    cls, implied_volatility_surface, variance_process, initial_spot,
    initial_variance, rho=None, risk_free_rate=None, dividend_yield=None,
    time_step=None, num_grid_points=None, grid_minimums=None, grid_maximums=None,
    dtype=None
)
```

Creates a `LocalStochasticVolatilityModel` from volatility surface.

This function computes the leverage function for the LSV model by first
computing the joint probablity density function `p(t, X(t), v(t))` where
`X(t)` is the log of the spot price and `v(t)` is the variance at time `t`.
The joint probablity density is computed using the Fokker-Planck equation of
the LSV model (see 6.8.2 in Ref [1]):
```None
dp/dt = 1/2 d^2 [v L(t,X)^2 p]/dX^2 + 1/2 d^2 [b(v)^2 p]/dv^2 +
        rho d^2 [sqrt(v)L(t,X)b(v) p]/dXdv -
        d[(r - d - 1/2 v L(t,X)^2)p]/dX -
        d[a(v) p]/dv
```

where `a(v)` and `b(v)` are the drift and diffusion functions for the
variance process. Defining

```None
I_n(k,t) = int v^n p(t, k, v) dv
```

we can calculate the leverage function as follows:
```None
L(k, t) = sigma(exp(k), t) sqrt(I_0(k, t)/I_1(k, t)).
```

#### Args:


* <b>`implied_volatility_surface`</b>: Either an instance of
  `processed_market_data.VolatilitySurface` or a Python object containing
  the implied volatility market data. If the input is a Python object,
  then the object must implement a function `volatility(strike,
  expiry_times)` which takes real `Tensor`s corresponding to option
  strikes and time to expiry and returns a real `Tensor` containing the
  corresponding market implied volatility.
* <b>`variance_process`</b>: An instance of `LSVVarianceModel` or
  `ItoProcess`specifying the dynamics of the variance process of
  the LSV model.
* <b>`initial_spot`</b>: A real scalar `Tensor` specifying the underlying spot price
  on the valuation date.
* <b>`initial_variance`</b>: A real scalar `Tensor` specifying the initial variance
  on the valuation date.
* <b>`rho`</b>: A real scalar `Tensor` specifying the correlation between spot price
  and the stochastic variance.
* <b>`risk_free_rate`</b>: A real scalar `Tensor` specifying the (continuosly
  compounded) risk free interest rate. If the underlying is an FX rate,
  then use this input to specify the domestic interest rate.
  Default value: `None` in which case the input is set to zero.
* <b>`dividend_yield`</b>: A real scalar `Tensor` specifying the (continuosly
  compounded) divident yield. If the underlying is an FX rate, then use
  this input to specify the foreign interest rate.
  Default value: `None` in which case the input is set to zero.
* <b>`time_step`</b>: An optional real scalar `Tensor` specifying the time step
  during the numerical solution of the Fokker-Planck PDE.
  Default value: None, in which case `time_step` corresponding to 100 time
    steps is used.
* <b>`num_grid_points`</b>: A scalar integer `Tensor` specifying the number of
  discretization points for each spatial dimension.
  Default value: None, in which case number of grid points is set to 100.
* <b>`grid_minimums`</b>: An optional `Tensor` of size 2 containing the minimum grid
  points for PDE spatial discretization. `grid_minimums[0]` correspond
  to the minimum spot price in the spatial grid and `grid_minimums[1]`
  correspond to the minimum variance value.
* <b>`grid_maximums`</b>: An optional `Tensor` of size 2 containing the maximum grid
  points for PDE spatial discretization. `grid_maximums[0]` correspond
  to the maximum spot price in the spatial grid and `grid_maximums[1]`
  correspond to the maximum variance value.
* <b>`dtype`</b>: The default dtype to use when converting values to `Tensor`s.
  Default value: `None` which means that default dtypes inferred by
    TensorFlow are used.


#### Returns:

An instance of `LocalStochasticVolatilityModel` constructed using the
input data.


<h3 id="name"><code>name</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
name()
```

The name to give to ops created by this class.


<h3 id="sample_paths"><code>sample_paths</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
sample_paths(
    times, num_samples=1, initial_state=None, random_type=None, seed=None,
    swap_memory=True, name=None, time_step=None, num_time_steps=None, skip=0,
    precompute_normal_draws=True, times_grid=None, normal_draws=None,
    watch_params=None, validate_args=False
)
```

Returns a sample of paths from the process using Euler sampling.

The default implementation uses the Euler scheme. However, for particular
types of Ito processes more efficient schemes can be used.

#### Args:


* <b>`times`</b>: Rank 1 `Tensor` of increasing positive real values. The times at
  which the path points are to be evaluated.
* <b>`num_samples`</b>: Positive scalar `int`. The number of paths to draw.
  Default value: 1.
* <b>`initial_state`</b>: `Tensor` of shape broadcastable
  `batch_shape + [num_samples, dim]`. The initial state of the process.
  `batch_shape` represents the shape of the independent batches of the
  stochastic process as in the `drift_fn` and `volatility_fn` of the
  underlying class. Note that the `batch_shape` is inferred from
  the `initial_state` and hence when sampling is requested for a batch of
  stochastic processes, the shape of `initial_state` should be as least
  `batch_shape + [1, 1]`.
  Default value: None which maps to a zero initial state.
* <b>`random_type`</b>: Enum value of `RandomType`. The type of (quasi)-random number
  generator to use to generate the paths.
  Default value: None which maps to the standard pseudo-random numbers.
* <b>`seed`</b>: Seed for the random number generator. The seed is
  only relevant if `random_type` is one of
  `[STATELESS, PSEUDO, HALTON_RANDOMIZED, PSEUDO_ANTITHETIC,
    STATELESS_ANTITHETIC]`. For `PSEUDO`, `PSEUDO_ANTITHETIC` and
  `HALTON_RANDOMIZED` the seed should be an Python integer. For
  `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as an integer
  `Tensor` of shape `[2]`.
  Default value: `None` which means no seed is set.
* <b>`swap_memory`</b>: A Python bool. Whether GPU-CPU memory swap is enabled for
  this op. See an equivalent flag in `tf.while_loop` documentation for
  more details. Useful when computing a gradient of the op since
  `tf.while_loop` is used to propagate stochastic process in time.
  Default value: True.
* <b>`name`</b>: Python string. The name to give this op.
  Default value: `None` which maps to `sample_paths` is used.
* <b>`time_step`</b>: An optional scalar real `Tensor` - maximal distance between
  points in the time grid.
  Either this or `num_time_steps` should be supplied.
  Default value: `None`.
* <b>`num_time_steps`</b>: An optional Scalar integer `Tensor` - a total number of
  time steps performed by the algorithm. The maximal distance between
  points in grid is bounded by
  `times[-1] / (num_time_steps - times.shape[0])`.
  Either this or `time_step` should be supplied.
  Default value: `None`.
* <b>`skip`</b>: `int32` 0-d `Tensor`. The number of initial points of the Sobol or
  Halton sequence to skip. Used only when `random_type` is 'SOBOL',
  'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.
  Default value: `0`.
* <b>`precompute_normal_draws`</b>: Python bool. Indicates whether the noise
  increments in Euler scheme are precomputed upfront (see
  <a href="../../../tf_quant_finance/models/euler_sampling/sample.md"><code>models.euler_sampling.sample</code></a>). For `HALTON` and `SOBOL` random types
  the increments are always precomputed. While the resulting graph
  consumes more memory, the performance gains might be significant.
  Default value: `True`.
* <b>`times_grid`</b>: An optional rank 1 `Tensor` representing time discretization
  grid. If `times` are not on the grid, then the nearest points from the
  grid are used.
  Default value: `None`, which means that times grid is computed using
  `time_step` and `num_time_steps`.
* <b>`normal_draws`</b>: A `Tensor` of shape
  `batch_shape + [num_samples, num_time_points, dim]`
  and the same `dtype` as `times`. Represents random normal draws to
  compute increments `N(0, t_{n+1}) - N(0, t_n)`. `batch_shape` is the
  shape of the independent batches of the stochastic process. When
  supplied, `num_sample`, `time_step` and `num_time_steps` arguments are
  ignored and the first dimensions of `normal_draws` are used instead.
* <b>`watch_params`</b>: An optional list of zero-dimensional `Tensor`s of the same
  `dtype` as `initial_state`. If provided, specifies `Tensor`s with
  respect to which the differentiation of the sampling function will
  happen. A more efficient algorithm is used when `watch_params` are
  specified. Note the the function becomes differentiable onlhy wrt to
  these `Tensor`s and the `initial_state`. The gradient wrt any other
  `Tensor` is set to be zero.
* <b>`validate_args`</b>: Python `bool`. When `True` and `normal_draws` are supplied,
  checks that `tf.shape(normal_draws)[1]` is equal to `num_time_steps`
  that is either supplied as an argument or computed from `time_step`.
  When `False` invalid dimension may silently render incorrect outputs.
  Default value: `False`.


#### Returns:

A real `Tensor` of shape `batch_shape + [num_samples, k, n]` where `k`
is the size of the `times`, and `n` is the dimension of the process.



#### Raises:


* <b>`ValueError`</b>:   (a) When `times_grid` is not supplied, and neither `num_time_steps` nor
    `time_step` are supplied or if both are supplied.
  (b) If `normal_draws` is supplied and `dim` is mismatched.
* <b>`tf.errors.InvalidArgumentError`</b>: If `normal_draws` is supplied and
  `num_time_steps` is mismatched.

<h3 id="volatility_fn"><code>volatility_fn</code></h3>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/generic_ito_process.py">View source</a>

```python
volatility_fn()
```

Python callable calculating the instantaneous volatility.

The callable should accept two real `Tensor` arguments of the same dtype and
shape `times_shape`. The first argument is the scalar time t, the second
argument is the value of Ito process X - `Tensor` of shape
`batch_shape + sample_shape + [dim]`, where `batch_shape` represents a batch
of models and `sample_shape` represents samples for each of the models. The
result is value of volatility S_{ij}(t, X). The return value of the callable
is a real `Tensor` of the same dtype as the input arguments and of shape
`batch_shape + sample_shape + [dim, dim]`. For example, `sample_shape` can
stand for `[num_samples]` for Monte Carlo sampling, or
`[num_grid_points_1, ..., num_grid_points_dim]` for Finite Difference
solvers.

#### Returns:

The instantaneous volatility callable.




