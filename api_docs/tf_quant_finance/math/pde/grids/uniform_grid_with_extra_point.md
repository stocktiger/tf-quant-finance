<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2022-05-30.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.math.pde.grids.uniform_grid_with_extra_point" />
<meta itemprop="path" content="Stable" />
</div>

# tf_quant_finance.math.pde.grids.uniform_grid_with_extra_point

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/math/pde/grids.py">View source</a>



Creates a grid spec for a uniform grid with an extra grid point.

```python
tf_quant_finance.math.pde.grids.uniform_grid_with_extra_point(
    minimums, maximums, sizes, extra_grid_point, dtype=None, validate_args=False,
    name=None
)
```



<!-- Placeholder for "Used in" -->

A uniform grid is characterized by having a constant gap between neighboring
points along each axis. An extra grid point is useful, for example, when
computing sensitivities for a value through a grid pricing method

#### Examples

```python
dtype = np.float64
extra_locations = tf.constant([[1, 2], [2, 3]], dtype=dtype)
min_x, max_x, sizes = [[0, 0], [0, 0]], [[10, 5], [100, 5]], [3, 2]
# Here min_x and max_x are in the original space and *not* in the log-space.
grid = uniform_grid_with_extra_point(
    min_x, max_x, sizes,
    extra_grid_point=extra_locations, dtype=dtype)
with tf.Session() as sess:
  grid = sess.run(grid)
# Note that the minimum and maximum grid locations are the same as min_x and
# max_x.
print(grid.locations[0])
# [[0, 1, 5, 10], [0, 2, 50, 100]]
print(grid.locations[1])
# [[0, 2, 5], [0, 3, 5]]
```

Note that the shape of all four parameters must be fully defined and equal
to each other. The shape is used to determine the dimension of the grid.

#### Args:


* <b>`minimums`</b>: Real `Tensor` of rank 1 or 2 containing the lower end points of
  the grid. Must have the same shape as those of `maximums`. When rank is 2
  the first dimension is the batch dimension.
* <b>`maximums`</b>: `Tensor` of the same dtype and shape as `minimums`. The upper
  endpoints of the grid.
* <b>`sizes`</b>: Integer rank 1 `Tensor` of the same shape as `minimums`. The size of
  the grid in each axis. Each entry must be greater than or equal to 2 (i.e.
  the sizes include the end points). For example, if minimums = [0.] and
  maximums = [1.] and sizes = [3], the grid will have three points at [0.0,
  0.5, 1.0].
* <b>`extra_grid_point`</b>: A `Tensor` of the same `dtype` as `minimums` and of shape
  `[batch_size, n]`, where `batch_shape` is a positive integer and `n` is
  the number of points along a dimension. These are the extra points added
  to the grid, so that the output grid `locations` have shape `[batch_shape,
  n+1]`.
* <b>`dtype`</b>: Optional tf.dtype. The default dtype to use for the grid.
* <b>`validate_args`</b>: Python boolean indicating whether to validate the supplied
  arguments. The validation checks performed are (a) `maximums` > `minimums`
  (b) `sizes` >= 2.
* <b>`name`</b>: Python str. The name prefixed to the ops created by this function. If
  not supplied, the default name 'uniform_grid_spec' is used.


#### Returns:

The grid locations as projected along each axis. One `Tensor` of shape
`[..., n]`, where `n` is the number of points along that axis. The first
dimensions are the batch shape. The grid itself can be seen as a cartesian
product of the locations array.



#### Raises:

ValueError if the shape of maximums, minimums and sizes are not fully
defined or they are not identical to each other or they are not rank 1.
