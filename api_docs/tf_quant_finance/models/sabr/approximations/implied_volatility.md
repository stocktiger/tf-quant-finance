<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2022-05-30.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.models.sabr.approximations.implied_volatility" />
<meta itemprop="path" content="Stable" />
</div>

# tf_quant_finance.models.sabr.approximations.implied_volatility

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/sabr/approximations/implied_volatility.py">View source</a>



Computes the implied volatility under the SABR model.

```python
tf_quant_finance.models.sabr.approximations.implied_volatility(
    *, strikes, expiries, forwards, alpha, beta, volvol, rho, shift=0.0, volatility_
    type=tf_quant_finance.models.sabr.approximations.SabrImpliedVolatilityType.LOGNO
    RMAL, approximation_type=tf_quant_finance.models.sabr.approximations.SabrApproxi
    mationType.HAGAN, dtype=None, name=None
)
```



<!-- Placeholder for "Used in" -->

The SABR model specifies the risk neutral dynamics of the underlying as the
following set of stochastic differential equations:

```
  dF = sigma F^beta dW_1
  dsigma = volvol sigma dW_2
  dW1 dW2 = rho dt

  F(0) = f
  sigma(0) = alpha
```
where F(t) represents the value of the forward price as a function of time,
and sigma(t) is the volatility.

Here, we implement an approximate solution as proposed by Hagan [1], and back
out the equivalent implied volatility that would've been obtained under either
the normal model or the Black model.

#### Example
```python
import tf_quant_finance as tff
import tensorflow.compat.v2 as tf

equiv_vol = tff.models.sabr.approximations.implied_volatility(
    strikes=np.array([106.0, 11.0]),
    expiries=np.array([17.0 / 365.0, 400.0 / 365.0]),
    forwards=np.array([120.0, 20.0]),
    alpha=1.63,
    beta=0.6,
    rho=0.00002,
    volvol=3.3,
    dtype=tf.float64)
# Expected: [0.33284656705268817, 1.9828728139982792]

# Running this inside a unit test passes:
# equiv_vol = self.evaluate(equiv_vol)
# self.assertAllClose(equiv_vol, 0.33284656705268817)
```
#### References
[1] Hagan et al, Managing Smile Risk, Wilmott (2002), 1:84-108

#### Args:


* <b>`strikes`</b>: Real `Tensor` of arbitrary shape, specifying the strike prices.
  Values must be strictly positive.
* <b>`expiries`</b>: Real `Tensor` of shape compatible with that of `strikes`,
  specifying the corresponding time-to-expiries of the options. Values must
  be strictly positive.
* <b>`forwards`</b>: Real `Tensor` of shape compatible with that of `strikes`,
  specifying the observed forward prices of the underlying. Values must be
  strictly positive.
* <b>`alpha`</b>: Real `Tensor` of shape compatible with that of `strikes`, specifying
  the initial values of the stochastic volatility. Values must be strictly
  positive.
* <b>`beta`</b>: Real `Tensor` of shape compatible with that of `strikes`, specifying
  the model exponent `beta`. Values must satisfy 0 <= `beta` <= 1.
* <b>`volvol`</b>: Real `Tensor` of shape compatible with that of `strikes`,
  specifying the model vol-vol multipliers. Values of `volvol` must be
  non-negative.
* <b>`rho`</b>: Real `Tensor` of shape compatible with that of `strikes`, specifying
  the correlation factors between the Wiener processes modeling the forward
  and the volatility. Values must satisfy -1 < `rho` < 1.
* <b>`shift`</b>: Optional `Tensor` of shape compatible with that of `strkies`,
  specifying the shift parameter(s). In the shifted model, the process
  modeling the forward is modified as: dF = sigma * (F + shift) ^ beta * dW.
  With this modification, negative forward rates are valid as long as
  F > -shift.
  Default value: 0.0
* <b>`volatility_type`</b>: Either SabrImpliedVolatility.NORMAL or LOGNORMAL.
  Default value: `LOGNORMAL`.
* <b>`approximation_type`</b>: Instance of `SabrApproxmationScheme`.
  Default value: `HAGAN`.
* <b>`dtype`</b>: Optional: `tf.DType`. If supplied, the dtype to be used for
  converting values to `Tensor`s.
  Default value: `None`, which means that the default dtypes inferred from
    `strikes` is used.
* <b>`name`</b>: str. The name for the ops created by this function.
  Default value: 'sabr_approx_implied_volatility'.


#### Returns:

A real `Tensor` of the same shape as `strikes`, containing the
corresponding equivalent implied volatilities.
